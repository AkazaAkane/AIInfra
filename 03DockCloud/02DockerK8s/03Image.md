<!--Copyright © ZOMI 适用于[License](https://github.com/Infrasys-AI/AIInfra)版权许可-->

# 容器镜像

Author by: 张柯帆

> 注：以下讨论基于 Linux

在深入探讨了实现“隔离”的 Namespace 和实现“限制”的 Cgroups 之后，我们终于触及了构成现代容器技术的第三根、也是最后一根关键支柱：**文件系统**。如果说 Namespace 和 Cgroups 定义了容器进程的**运行时边界**，那么一个高效、分层的文件系统则定义了容器的**静态构建块**，也就是我们所熟知的“镜像”。

## Union File Systems：构建容器镜像的基石

我们先从一个看似简单的问题开始：Docker 如何存储和管理镜像？一个典型的应用镜像，比如 `ubuntu:latest`，可能包含数百 MB 的文件。如果我们每创建一个容器，都完整地复制一份基础镜像，那么磁盘空间将很快被耗尽，容器的启动速度也会变得无法接受。这显然不是一个可行的方案。

真正的需求是：**实现镜像文件的最大化复用，同时为每个容器提供一个看似独立、可写的根文件系统。**

这个需求的解决方案，正是 **Union File Systems (UFS)**，也称为联合文件系统。其核心思想，就是将多个不同的目录（我们称之为**分支 branch** 或**层 layer**）的内容，在同一个挂载点（mount point）下进行“叠加”，形成一个单一、统一的视图。

想象一下，我们有多个只读的目录层（lower directories）和一个可写的目录层（upper directory）。UFS 会将它们“堆叠”起来：

![UFS](./images/03Image01.webp)

*   当读取文件时，UFS 会从最上层的可写层开始查找。如果找到，则直接返回。如果找不到，则逐层向下到只读层查找。
*   当修改文件时，如果文件位于下层的只读层，U.S. 会触发 **写时复制 (Copy-on-Write, CoW)** 机制。它会先将只读文件**复制**到最上层的可写层，然后再对这个副本进行修改。原始的只读文件保持不变。
*   当删除文件时，如果文件位于下层，由于下层是只读的，我们无法真正删除它。UFS 会在可写层创建一个特殊的“白障”(whiteout) 文件，用来“遮挡”下层的文件，使其在统一视图中不可见。
*   当创建新文件时，文件会直接被创建在最上层的可写层中。

这种机制的精妙之处在于，所有容器都可以共享只读的基础镜像层，只有当容器需要修改数据时，才会产生增量写入。这不仅极大地节省了磁盘空间，还使得容器的创建和销毁变得极其迅速，因为我们无需进行大规模的文件复制。

### AUFS (Another Union File System)

AUFS，作为 UnionFS 的一个重要分支和重新实现，是早期 Docker 能够迅速崛起的关键技术功臣。尽管它从未被正式合入 Linux 内核主线，但这并不妨碍我们对其设计思想和实现细节进行深入探讨。

![AUFS](./images/03Image02.jpg)

#### 架构与原理

AUFS 的核心是“分支”（Branches）。它可以将多达 127 个分支（目录）联合挂载到一个挂载点上。这些分支被赋予不同的权限，通常是一个可写分支（writable branch）和多个只读分支（read-only branches）。

当挂载时，AUFS 会构建一个内存中的视图，该视图包含了所有分支的文件和目录信息。其 CoW 机制堪称经典：当一个进程试图修改一个来自只读分支的文件时，AUFS 内核模块会拦截这个写操作。它首先在可写分支中创建一个与目标文件路径完全相同的空文件，然后将只读分支中的数据**按需**复制到这个新创建的文件中，最后才将写操作应用到这个副本上。这个过程被称为“copy-up”。

#### 关键技术点与实现细节

1.  **Inode 的处理**：AUFS 在处理 inode 时面临一个挑战。由于不同分支上的文件是独立的，它们拥有不同的 inode。当它们被联合到同一个视图时，AUFS 必须在内部维护一个 inode 映射表，以确保从用户空间的视角来看，同一个文件路径始终对应一个稳定的 inode。这增加了其实现的复杂性。

2.  **删除操作与 Whiteouts**：AUFS 的 Whiteout 机制非常直观。当用户在联合视图中删除一个来自只读分支的文件（例如 `/app/config.ini`）时，AUFS 会在可写分支中创建一个名为 `.wh.config.ini` 的特殊文件。当 AUFS 遍历目录时，一旦遇到 `.wh.` 前缀的文件，它就会将对应的原始文件从联合视图中“隐藏”起来。这种基于文件名的标记方式简单有效，但也带来了一定的性能开销，因为每次 `readdir` 都需要进行额外的检查。

3.  **强大的分支管理**：AUFS 的一个显著特点是其灵活的分支管理能力。它不仅支持在运行时动态地添加或删除分支，甚至支持拥有多个可写分支。虽然这个特性在容器场景中不常用，但它展示了 AUFS 设计的灵活性。

#### 衰落的原因

AUFS 最大的问题，也是其最终被 OverlayFS 取代的根本原因，是**它从未被合并到 Linux 内核主线**。这意味着要使用 AUFS，发行版厂商需要手动为内核打上 AUFS 的补丁。这不仅增加了维护成本，也带来了稳定性和安全性的隐忧。其代码实现异常复杂，包含了大量的“黑魔法”，这让内核社区的维护者们望而却步。

尽管如此，AUFS 作为先行者，为后续的 UFS 技术（尤其是 OverlayFS）提供了宝贵的实践经验和教训。

### OverlayFS (overlay & overlay2)

随着内核社区对容器技术的需求日益增长，一个更简洁、更高效且能够被主线接纳的 UFS 实现变得至关重要。OverlayFS 应运而生，并迅速演进到了其第二个、也是目前作为事实标准的版本——**overlay2**。

OverlayFS 的设计哲学与 AUFS 有显著不同，它更加贴近 VFS（虚拟文件系统）的通用模型，实现也更为简洁优雅。

![overlay](./images/03Image03.jpg)

#### 架构与核心组件

Overlay2 的架构由四个关键目录组成：`lowerdir`, `upperdir`, `merged`, 和 `workdir`。

*   `lowerdir`: 相当于只读层。Overlay2 的一个重大改进是支持多个 `lowerdir`，通过冒号 `:` 分隔，实现了真正的多层镜像支持。例如：`lowerdir=/layer1:/layer2:/layer3`。
*   `upperdir`: 唯一的可写层，所有的写入操作最终都会反映在这里。
*   `merged`: 统一的联合视图，也就是容器的挂载点。它将 `upperdir` 叠加在 `lowerdir` 之上。
*   `workdir`: 这是一个内部使用的工作目录，要求与 `upperdir` 在同一个文件系统上。Overlay2 在执行 copy-up 等原子操作时，会先在 `workdir` 中进行准备，完成后再通过 `rename` 系统调用将其原子性地移动到 `upperdir`。这保证了即使在操作过程中发生意外（如断电），文件系统也不会处于不一致的状态。

#### 关键技术点与实现细节

1.  **高效的 Copy-Up 与 Inode 共享**：Overlay2 的 copy-up 操作通常比 AUFS 更快。更重要的是，对于未被修改的文件，Overlay2 使得 `merged` 视图中的文件可以直接共享 `lowerdir` 中对应文件的 inode。这意味着在执行 `stat` 等元数据操作时，内核无需进行额外的转换或查找，性能接近原生文件系统。只有当文件被 copy-up 到 `upperdir` 后，它才会在 `upperdir` 中获得一个新的 inode。

2.  **目录修改与 `redirect_dir`**：当需要修改一个来自 `lowerdir` 的目录元数据时（例如修改权限 `chmod`），Overlay2 会在 `upperdir` 中复制这个目录，并在其扩展属性（xattr）中设置一个名为 `trusted.overlay.redirect` 的标记，指向 `lowerdir` 中原始目录的路径。这样，当访问这个目录时，虽然元数据来自 `upperdir`，但其内容仍然可以高效地从 `lowerdir` 读取。

3.  **硬链接 (Hard Link) 的处理**：硬链接是 UFS 实现中的一个经典难题。在 OverlayFS 中，如果一个文件在 `lowerdir` 中有多个硬链接，当这个文件被 copy-up 时，OverlayFS 必须保证在 `upperdir` 中也维持这种硬链接关系。Overlay2 通过在 `upperdir` 的根目录维护一个索引（`index` 目录）来追踪被复制过的文件的原始 `lowerdir` 路径和 inode，确保 copy-up 操作的幂等性和硬链接的正确性。

4.  **删除操作与字符设备 Whiteout**：与 AUFS 使用特殊文件名的 Whiteout 不同，OverlayFS 采用了一种更符合 POSIX 标准的方式。当删除一个来自 `lowerdir` 的文件时，它会在 `upperdir` 中创建一个同名的**字符设备文件（character device），其设备号为 0/0**。VFS 层在解析目录时，看到这种特殊的字符设备，就会理解为这是一个 Whiteout 标记，从而隐藏 `lowerdir` 中的对应文件。这种方式比解析文件名要高效且优雅。

### 对比 AUFS 和 Overlay2

| 特性              | AUFS (Another Union File System)                              | Overlay2 (OverlayFS v2)                                                     | 优胜者分析                                                                                          |
| :---------------- | :------------------------------------------------------------ | :-------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------- |
| **内核集成**      | **内核之外 (Out-of-Tree)**                                    | **内核主线 (Mainline)**                                                     | **Overlay2 (压倒性优势)**。这是决定性的因素。主线意味着更好的稳定性、安全性、性能和长期的社区支持。 |
| **Inode 使用**    | 每个文件在每个层都有独立的 Inode，可能导致 Inode 耗尽。       | 共享来自 `lowerdir` 的 Inode，仅在 copy-up 后才在 `upperdir` 创建新 Inode。 | **Overlay2**。Inode 使用效率更高，特别适合高密度容器和深度镜像的场景。                              |
| **性能**          | copy-up 相对较慢，`readdir` 操作因 `.wh` 文件检查有额外开销。 | copy-up 通常更快，元数据操作（如 `stat`）因 Inode 共享接近原生性能。        | **Overlay2**。在大多数场景下，尤其是在文件创建、修改和元数据访问方面，性能更优。                    |
| **实现复杂度**    | 极其复杂，代码量大，难以维护。                                | 设计简洁，代码更易于理解和维护，更符合 VFS 模型。                           | **Overlay2**。简洁的设计带来了更好的稳定性和可维护性。                                              |
| **Whiteout 机制** | 基于文件名前缀 (`.wh.`)。                                     | 使用字符设备 (cdev, 0/0)。                                                  | **Overlay2**。技术上更优雅，且对 `readdir` 等操作更友好。                                           |
| **内存使用**      | 通常比 OverlayFS 消耗更多的内核内存。                         | 更节省内存。                                                                | **Overlay2**。对于高密度部署环境，内存效率至关重要。                                                |

## 总结

至此，我们完成了容器技术三大支柱的探索之旅。

*   **Namespaces** 欺骗了进程的“眼睛”，构建了隔离的视图。
*   **Cgroups** 给进程戴上了“镣铐”，限制了资源的滥用。
*   **Union File Systems** 保证了容器的一致性和轻便性，使得容器的分发、存储和实例化变得轻盈而高效。

从 AUFS 的大胆探索，到 Overlay2 的成熟稳健，我们看到了开源社区如何在实践中不断迭代，最终打造出符合内核哲学、兼具性能与稳定性的卓越技术。可以说，没有 Overlay2 这样稳定高效的 UFS 实现，就不可能有今天云原生生态的繁荣。

## 参考与引用

- https://docker-docs.uclv.cu/storage/storagedriver/aufs-driver/
- https://blog.csdn.net/luckyapple1028/article/details/77916194
